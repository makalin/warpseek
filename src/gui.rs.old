use anyhow::{anyhow, Result};
use directories::ProjectDirs;
use std::path::Path;
use std::sync::{Arc, Mutex};
use tantivy::{Index, doc, ReloadPolicy, collector::TopDocs, query::QueryParser};
use serde::{Serialize, Deserialize};
use regex::Regex;
use uuid::Uuid;

// Import the core functionality from search module
use crate::search::{Config, Fields, open_index, read_config};

#[derive(Serialize, Deserialize, Clone)]
pub struct SearchResult {
    pub id: String,
    pub path: String,
    pub name: String,
    pub content_preview: String,
    pub modified: i64,
    pub score: f32,
    pub file_type: String,
    pub size: u64,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct SearchQuery {
    pub query: String,
    pub search_type: SearchType,
    pub file_types: Vec<String>,
    pub max_results: usize,
    pub case_sensitive: bool,
    pub use_regex: bool,
    pub modified_after: Option<i64>,
    pub modified_before: Option<i64>,
    pub size_min: Option<u64>,
    pub size_max: Option<u64>,
}

#[derive(Serialize, Deserialize, Clone)]
pub enum SearchType {
    FullText,
    Filename,
    Regex,
    Content,
}

#[derive(Serialize, Deserialize, Default)]
pub struct SearchHistory {
    pub queries: Vec<SearchQuery>,
    pub max_entries: usize,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Bookmark {
    pub id: String,
    pub name: String,
    pub path: String,
    pub created: i64,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct SearchFilters {
    pub file_extensions: Vec<String>,
    pub exclude_patterns: Vec<String>,
    pub include_patterns: Vec<String>,
    pub max_file_size: u64,
    pub min_file_size: u64,
}

pub struct SearchEngine {
    index: Index,
    fields: Fields,
    config: Config,
    search_history: Arc<Mutex<SearchHistory>>,
    bookmarks: Arc<Mutex<Vec<Bookmark>>>,
    filters: Arc<Mutex<SearchFilters>>,
}

impl SearchEngine {
    pub fn new() -> Result<Self> {
        let project_dirs = ProjectDirs::from("io", "frangedev", "warpseek")
            .ok_or_else(|| anyhow!("cannot resolve project dirs"))?;
        
        let index_dir = project_dirs.data_dir().join("index");
        let (index, fields) = open_index(&index_dir)?;
        let config = read_config()?;
        
        Ok(Self {
            index,
            fields,
            config,
            search_history: Arc::new(Mutex::new(SearchHistory {
                queries: Vec::new(),
                max_entries: 100,
            })),
            bookmarks: Arc::new(Mutex::new(Vec::new())),
            filters: Arc::new(Mutex::new(SearchFilters {
                file_extensions: vec!["txt".to_string(), "md".to_string(), "rs".to_string(), "js".to_string(), "py".to_string()],
                exclude_patterns: vec!["node_modules".to_string(), ".git".to_string()],
                include_patterns: Vec::new(),
                max_file_size: 20 * 1024 * 1024, // 20MB
                min_file_size: 0,
            })),
        })
    }

    pub fn search(&self, query: SearchQuery) -> Result<Vec<SearchResult>> {
        let reader = self.index.reader_builder()
            .reload_policy(ReloadPolicy::Manual)
            .try_into()?;
        let searcher = reader.searcher();

        // Add to search history
        {
            let mut history = self.search_history.lock().unwrap();
            history.queries.insert(0, query.clone());
            let max_entries = history.max_entries;
            if history.queries.len() > max_entries {
                history.queries.truncate(max_entries);
            }
        }

        let results = match query.search_type {
            SearchType::FullText => self.search_full_text(&searcher, &query)?,
            SearchType::Filename => self.search_filename(&searcher, &query)?,
            SearchType::Regex => self.search_regex(&searcher, &query)?,
            SearchType::Content => self.search_content(&searcher, &query)?,
        };

        Ok(results)
    }

    fn search_full_text(&self, searcher: &tantivy::Searcher, query: &SearchQuery) -> Result<Vec<SearchResult>> {
        let qp = QueryParser::for_index(&self.index, vec![self.fields.content, self.fields.name]);
        let tantivy_query = qp.parse_query(&query.query)?;
        let top_docs = searcher.search(&tantivy_query, &TopDocs::with_limit(query.max_results))?;
        
        let mut results = Vec::new();
        for (score, docaddr) in top_docs {
            let doc = searcher.doc(docaddr)?;
            let path = doc.get_first(self.fields.path).and_then(|v| v.text()).unwrap_or("");
            let name = doc.get_first(self.fields.name).and_then(|v| v.text()).unwrap_or("");
            let content = doc.get_first(self.fields.content).and_then(|v| v.text()).unwrap_or("");
            let modified = doc.get_first(self.fields.modified).and_then(|v| v.i64_value()).unwrap_or(0);
            
            let content_preview = if content.len() > 200 {
                format!("{}...", &content[..200])
            } else {
                content.to_string()
            };

            let file_type = Path::new(path).extension()
                .and_then(|ext| ext.to_str())
                .unwrap_or("")
                .to_string();

            results.push(SearchResult {
                id: Uuid::new_v4().to_string(),
                path: path.to_string(),
                name: name.to_string(),
                content_preview,
                modified,
                score,
                file_type,
                size: 0, // Would need to be stored separately
            });
        }
        
        Ok(results)
    }

    fn search_filename(&self, searcher: &tantivy::Searcher, query: &SearchQuery) -> Result<Vec<SearchResult>> {
        let qp = QueryParser::for_index(&self.index, vec![self.fields.name]);
        let tantivy_query = qp.parse_query(&query.query)?;
        let top_docs = searcher.search(&tantivy_query, &TopDocs::with_limit(query.max_results))?;
        
        let mut results = Vec::new();
        for (score, docaddr) in top_docs {
            let doc = searcher.doc(docaddr)?;
            let path = doc.get_first(self.fields.path).and_then(|v| v.text()).unwrap_or("");
            let name = doc.get_first(self.fields.name).and_then(|v| v.text()).unwrap_or("");
            let modified = doc.get_first(self.fields.modified).and_then(|v| v.i64_value()).unwrap_or(0);
            
            let file_type = Path::new(path).extension()
                .and_then(|ext| ext.to_str())
                .unwrap_or("")
                .to_string();

            results.push(SearchResult {
                id: Uuid::new_v4().to_string(),
                path: path.to_string(),
                name: name.to_string(),
                content_preview: String::new(),
                modified,
                score,
                file_type,
                size: 0,
            });
        }
        
        Ok(results)
    }

    fn search_regex(&self, searcher: &tantivy::Searcher, query: &SearchQuery) -> Result<Vec<SearchResult>> {
        let regex = if query.case_sensitive {
            Regex::new(&query.query)?
        } else {
            Regex::new(&format!("(?i){}", query.query))?
        };

        let qp = QueryParser::for_index(&self.index, vec![self.fields.content, self.fields.name]);
        let tantivy_query = qp.parse_query(&query.query)?;
        let top_docs = searcher.search(&tantivy_query, &TopDocs::with_limit(query.max_results))?;
        
        let mut results = Vec::new();
        for (score, docaddr) in top_docs {
            let doc = searcher.doc(docaddr)?;
            let path = doc.get_first(self.fields.path).and_then(|v| v.text()).unwrap_or("");
            let name = doc.get_first(self.fields.name).and_then(|v| v.text()).unwrap_or("");
            let content = doc.get_first(self.fields.content).and_then(|v| v.text()).unwrap_or("");
            let modified = doc.get_first(self.fields.modified).and_then(|v| v.i64_value()).unwrap_or(0);
            
            // Check if regex matches
            if regex.is_match(content) || regex.is_match(name) {
                let content_preview = if content.len() > 200 {
                    format!("{}...", &content[..200])
                } else {
                    content.to_string()
                };

                let file_type = Path::new(path).extension()
                    .and_then(|ext| ext.to_str())
                    .unwrap_or("")
                    .to_string();

                results.push(SearchResult {
                    id: Uuid::new_v4().to_string(),
                    path: path.to_string(),
                    name: name.to_string(),
                    content_preview,
                    modified,
                    score,
                    file_type,
                    size: 0,
                });
            }
        }
        
        Ok(results)
    }

    fn search_content(&self, searcher: &tantivy::Searcher, query: &SearchQuery) -> Result<Vec<SearchResult>> {
        let qp = QueryParser::for_index(&self.index, vec![self.fields.content]);
        let tantivy_query = qp.parse_query(&query.query)?;
        let top_docs = searcher.search(&tantivy_query, &TopDocs::with_limit(query.max_results))?;
        
        let mut results = Vec::new();
        for (score, docaddr) in top_docs {
            let doc = searcher.doc(docaddr)?;
            let path = doc.get_first(self.fields.path).and_then(|v| v.text()).unwrap_or("");
            let name = doc.get_first(self.fields.name).and_then(|v| v.text()).unwrap_or("");
            let content = doc.get_first(self.fields.content).and_then(|v| v.text()).unwrap_or("");
            let modified = doc.get_first(self.fields.modified).and_then(|v| v.i64_value()).unwrap_or(0);
            
            let content_preview = if content.len() > 200 {
                format!("{}...", &content[..200])
            } else {
                content.to_string()
            };

            let file_type = Path::new(path).extension()
                .and_then(|ext| ext.to_str())
                .unwrap_or("")
                .to_string();

            results.push(SearchResult {
                id: Uuid::new_v4().to_string(),
                path: path.to_string(),
                name: name.to_string(),
                content_preview,
                modified,
                score,
                file_type,
                size: 0,
            });
        }
        
        Ok(results)
    }

    pub fn get_search_history(&self) -> Result<Vec<SearchQuery>> {
        let history = self.search_history.lock().unwrap();
        Ok(history.queries.clone())
    }

    pub fn add_bookmark(&self, bookmark: Bookmark) -> Result<()> {
        let mut bookmarks = self.bookmarks.lock().unwrap();
        bookmarks.push(bookmark);
        Ok(())
    }

    pub fn get_bookmarks(&self) -> Result<Vec<Bookmark>> {
        let bookmarks = self.bookmarks.lock().unwrap();
        Ok(bookmarks.clone())
    }

    pub fn update_filters(&self, filters: SearchFilters) -> Result<()> {
        let mut current_filters = self.filters.lock().unwrap();
        *current_filters = filters;
        Ok(())
    }

    pub fn get_filters(&self) -> Result<SearchFilters> {
        let filters = self.filters.lock().unwrap();
        Ok(filters.clone())
    }
}

// Tauri commands
#[tauri::command]
fn search_files(
    engine: tauri::State<'_, Arc<Mutex<SearchEngine>>>,
    query: SearchQuery,
) -> Result<Vec<SearchResult>, String> {
    let engine = engine.lock().unwrap();
    engine.search(query).map_err(|e| e.to_string())
}

#[tauri::command]
fn get_search_history(
    engine: tauri::State<'_, Arc<Mutex<SearchEngine>>>,
) -> Result<Vec<SearchQuery>, String> {
    let engine = engine.lock().unwrap();
    engine.get_search_history().map_err(|e| e.to_string())
}

#[tauri::command]
fn add_bookmark(
    engine: tauri::State<'_, Arc<Mutex<SearchEngine>>>,
    bookmark: Bookmark,
) -> Result<(), String> {
    let engine = engine.lock().unwrap();
    engine.add_bookmark(bookmark).map_err(|e| e.to_string())
}

#[tauri::command]
fn get_bookmarks(
    engine: tauri::State<'_, Arc<Mutex<SearchEngine>>>,
) -> Result<Vec<Bookmark>, String> {
    let engine = engine.lock().unwrap();
    engine.get_bookmarks().map_err(|e| e.to_string())
}

#[tauri::command]
fn update_filters(
    engine: tauri::State<'_, Arc<Mutex<SearchEngine>>>,
    filters: SearchFilters,
) -> Result<(), String> {
    let engine = engine.lock().unwrap();
    engine.update_filters(filters).map_err(|e| e.to_string())
}

#[tauri::command]
fn get_filters(
    engine: tauri::State<'_, Arc<Mutex<SearchEngine>>>,
) -> Result<SearchFilters, String> {
    let engine = engine.lock().unwrap();
    engine.get_filters().map_err(|e| e.to_string())
}

#[tauri::command]
fn open_file(path: String) -> Result<(), String> {
    #[cfg(target_os = "macos")]
    {
        std::process::Command::new("open")
            .arg(&path)
            .spawn()
            .map_err(|e| e.to_string())?;
    }
    #[cfg(target_os = "linux")]
    {
        std::process::Command::new("xdg-open")
            .arg(&path)
            .spawn()
            .map_err(|e| e.to_string())?;
    }
    #[cfg(target_os = "windows")]
    {
        std::process::Command::new("cmd")
            .args(["/C", "start", "", &path])
            .spawn()
            .map_err(|e| e.to_string())?;
    }
    Ok(())
}

#[tauri::command]
fn open_folder(path: String) -> Result<(), String> {
    #[cfg(target_os = "macos")]
    {
        std::process::Command::new("open")
            .arg("-R")
            .arg(&path)
            .spawn()
            .map_err(|e| e.to_string())?;
    }
    #[cfg(target_os = "linux")]
    {
        std::process::Command::new("xdg-open")
            .arg(&path)
            .spawn()
            .map_err(|e| e.to_string())?;
    }
    #[cfg(target_os = "windows")]
    {
        std::process::Command::new("explorer")
            .arg(&path)
            .spawn()
            .map_err(|e| e.to_string())?;
    }
    Ok(())
}

fn main() {
    tauri::Builder::default()
        .manage(Arc::new(Mutex::new(SearchEngine::new().expect("Failed to initialize search engine"))))
        .invoke_handler(tauri::generate_handler![
            search_files,
            get_search_history,
            add_bookmark,
            get_bookmarks,
            update_filters,
            get_filters,
            open_file,
            open_folder
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
